set nocompatible      " We're running Vim, not Vi

let $PATH = '~/bin:/usr/local/bin:/usr/local/sbin:' . $PATH

set clipboard+=unnamed

set encoding=utf8 nobomb " BOM often causes trouble
let mapleader = ","   " <leader> now means ',' rather than '\'
if &t_Co > 1
  syntax enable       " Enable syntax highlighting without clobbering colors
endif
filetype on           " Enable filetype detection
filetype indent on    " Enable filetype-specific indenting
filetype plugin on    " Enable filetype-specific plugin
behave xterm
set visualbell        " must turn visual bell on to remove audio bell
set linebreak                 " when wrapping, try to break at characters in breakat
set breakat=\ ^I!@*-+;:,./?   " when wrapping, break at these characters
set showbreak=>               " character to show that a line is wrapped
set ignorecase    " ignore case when searching
set smartcase     " override ignorecase when there are uppercase characters
set showmatch     " when inserting a bracket briefly flash its match
set modeline
set number        " display line numbers
set mouse=a
set history=500
set showcmd
set title
set scrolloff=5
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
colorscheme desert
set incsearch
set hlsearch
nmap <silent> <leader>n :silent :nohlsearch<CR>
set shortmess=atI

set signcolumn=yes   " persistent sign column

set autoindent
set tabstop=2
set softtabstop=2
set shiftwidth=2
set laststatus=2
set expandtab
set smarttab
autocmd FileType make     set noexpandtab
if !has('nvim')
  set cm=blowfish  " when encrypting files with :X, use blowfish instead of hopelessly insecure zip
endif
set ruler
set statusline=%<%f\ %h%m%r%=%-14.(%l,%c%V%)\ %P>

" Setup automatic text formatting/wrapping:
set formatoptions=
set formatoptions-=t " Don't autowrap text
set formatoptions+=c " Do autowrap comments
set formatoptions+=r " Automatically continue comments
set formatoptions+=o " Automatically continue comments when hitting 'o' or 'O'
set formatoptions+=q " Allow formatting of comments with 'gq'
set formatoptions+=n " Recognize numbered lists
set formatoptions+=l " Don't break long lines that were already there

" Make window splitting behave
set noequalalways
set splitbelow

set backspace=eol,start,indent " make backspace work
"set hidden " no need to save to change buffers
" shellslash (use a common path separator across all platforms)
" convert all backslashes to forward slashes on expanding filenames.
" Enables consistancy in Cream between Windows and Linux platforms,
" but BE CAREFUL! Windows file operations require backslashes--any
" paths determined manually (not by Vim) need to be reversed.
set shellslash
" By default, pressing <TAB> in command mode will choose the first possible
" completion with no indication of how many others there might be. The following
" configuration lets you see what your other options are
set wildmenu
set wildmode=list:longest

" Search for ctags from current dir up to root
" set tags=./tags;
"   disabled - easytags uses ~/.vimtags


" Restore cursor position
autocmd BufReadPost *
  \ if line("'\"") > 1 && line("'\"") <= line("$") |
  \   exe "normal! g`\"" |
  \ endif

" lcd to directory of file on entering buffer
autocmd BufEnter * silent! lcd %:p:h

" Don't write backup file if vim is being called by "crontab -e"
au BufWrite /private/tmp/crontab.* set nowritebackup
au BufWrite /private/tmp/crontab.* set nobackup

" Reload this vimrc when it changes
augroup myvimrc
  if has('nvim')
    let expanded_vimrc = resolve(expand($MYVIMRC)) . ',' . resolve(expand('~/.vim/vimrc'))
    let expanded_gvimrc = resolve(expand($MYGVIMRC)) . ',' . resolve(expand('~/.vim/vimrc'))
  else
    let expanded_vimrc = resolve(expand($MYVIMRC))
    let expanded_gvimrc = resolve(expand($MYGVIMRC))
  endif
  autocmd!
  execute 'autocmd! BufWritePost $MYVIMRC,' . expanded_vimrc . ' tabdo windo source $MYVIMRC | filetype detect | redraw'
  execute 'autocmd! BufWritePost $MYGVIMRC,' . expanded_gvimrc . ' if has("gui_running") | tabdo windo so $MYGVIMRC | filetype detect | redraw | endif'
augroup END


" Mappings
inoremap ( ()<Left>
inoremap [ []<Left>
inoremap { {}<Left>

inoremap ) <c-r>=ClosePair(')')<CR>
inoremap ] <c-r>=ClosePair(']')<CR>
inoremap } <c-r>=ClosePair('}')<CR>

inoremap " <c-r>=QuoteDelim('"')<CR>
"inoremap ' <c-r>=QuoteDelim("'")<CR>

" New line below, above
inoremap <S-CR> <ESC>o
inoremap <C-CR> <ESC><S-o>

" <C-e> and <C-y> scroll the viewport a single line
nnoremap <C-e> 3<C-e>
nnoremap <C-y> 3<C-y>

" Substitute the word under the cursor
nnoremap <Leader>s :%s/\C\<<C-r><C-w>\>//gc<Left><Left><Left>
vnoremap <Leader>s y:%s/\C\<<C-r>"\>//gc<Left><Left><Left>

" Refactoring: rename local variable
"   gd - jump to definition of word under cursor
"   [{ - jump to start of block
"   V  - visual block mode
"   %  - jump to end of block
"   :  - command mode
"   s/ - substitude 
"   <C-R>/ - insert text of last search
"   //gd<left><left><left> - finish subtitute command and move cursor
nmap gr gd[{V%:s/<C-R>///gc<left><left><left>
" Refactoring: rename variable across whole file
"   [{ - jump to start of block
"   V  - visual block mode
"   %  - jump to end of block
"   :  - command mode
"   s/ - substitude 
"   <C-R>/ - insert text of last search
"   //gd<left><left><left> - finish subtitute command and move cursor
nnoremap gR gD:%s/<C-R>///gc<left><left><left>

" Alt mapped keys (none of these work on mac)
inoremap <m-[> [
inoremap <m-9> (
inoremap <m--> {
inoremap <m-"> "
inoremap <m-'> '

function! ClosePair(char)
  if getline('.')[col('.') - 1] == a:char
    return "\<Right>"
  else
    return a:char
  endif
endfunction
function! CloseBracket()
  if match(getline(line('.') + 1), '\s*}') < 0
    return "\<CR>}"
  else
    return "\<ESC>j0f}a"
  endif
endfunction
function! QuoteDelim(char)
  let line = getline('.')
  let col = col('.')
  if line[col - 2] == "\\"
    "Inserting a quoted quotation mark into the string
    return a:char
  elseif line[col - 1] == a:char
    "Escaping out of the string
    return "\<Right>"
  else
    "Starting a string
    return a:char.a:char."\<ESC>i"
  endif
endfunction

" CDC = Change to Directory of Current file
command! CDC cd %:p:h

" Plugins
" #######

" vim-plug
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall | source $MYVIMRC
endif
call plug#begin('~/.vim/bundle')
Plug 'neomake/neomake' " Async make (linters, syntax checke)
" Plug 'scrooloose/nerdtree', { 'on':  'NERDTreeToggle' } " File explorer
Plug 'scrooloose/syntastic' " Syntastic: Code linting errors
Plug 'mileszs/ack.vim' " File search with ack
Plug 'tpope/vim-surround' " Easily delete, change and add surroundings in pairs
" Plug 'wellle/targets.vim'
Plug 'tpope/vim-eunuch' " Unix shell commands that act on the file and the buffer simultaneously
Plug 'tpope/vim-commentary' " Comment toggle
Plug 'tpope/vim-repeat' " Make plugin commands repeatable with .
Plug 'tpope/vim-endwise' " Auto close if, do, def, etc.
Plug '/usr/local/opt/fzf' " fzf fuzzy finder
Plug 'junegunn/fzf.vim'
" Plug 'inkarkat/vim-SyntaxRange' " (lots of potential, but doesn't work reliably)
Plug 'xolox/vim-misc'
Plug 'xolox/vim-easytags'
Plug 'rizzatti/dash.vim'
Plug 'ctrlpvim/ctrlp.vim'
Plug 'vim-airline/vim-airline'

" vim-plug filetypes
Plug 'tpope/vim-git', { 'for': 'git' }
Plug 'vim-ruby/vim-ruby', { 'for': 'ruby' }
Plug 'tpope/vim-rails', { 'for': 'ruby' }
Plug 'ecomba/vim-ruby-refactoring', { 'for': 'ruby' }
Plug 'jgdavey/vim-blockle', { 'for': 'ruby' } " <leader>b to toggle Ruby block style
Plug 'tpope/vim-rake', { 'for': 'ruby' }
Plug 'tpope/vim-bundler', { 'for': 'ruby' }
Plug 'plasticboy/vim-markdown', { 'for': 'markdown' }
Plug 'pangloss/vim-javascript', { 'for': 'javascript' }
Plug 'vim-scripts/vim-coffee-script', { 'for': 'coffee' }
Plug 'dag/vim-fish', { 'for': 'fish' }
Plug 'thalesmello/lkml.vim', { 'for': 'lkml' }
Plug 'rodjek/vim-puppet', { 'for': 'puppet' }
Plug 'tbastos/vim-lua', { 'for': 'lua' } " syntax highlighting only
Plug 'xolox/vim-lua-ftplugin', { 'for': 'lua' }
Plug 'ElmCast/elm-vim'
Plug 'ndmitchell/ghcid', { 'rtp': 'plugins/nvim' }
Plug 'leafo/moonscript-vim'
call plug#end()


" vim-easytags
let g:easytags_async=1

" dash.vim plugin
:nmap <silent> <leader>d <Plug>DashSearch

" rails.vim plugin
let g:rails_level=4
let g:rails_subversion=1
" /rails.vim

" NERDTree plugin
let NERDTreeIgnore=['\~$', '^\.git', '\.swp$', '\.DS_Store$']
let NERDTreeShowHidden=1
" /NERDTree

" Blockle plugin
" <leader>b to change block style from { … } to do … end

" Syntastic plugin
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
let g:syntastic_always_populate_loc_list=1
let g:syntastic_enable_signs=1
let g:syntastic_auto_loc_list=1
let g:syntastic_check_on_open=1
let g:syntastic_check_on_wq=0
" /Syntastic

" vim-surround plugin
nmap <leader>c <Plug>CommentaryLine
nmap <leader>C <Plug>CommentaryLine
vmap <leader>c gc
vmap <leader>C gc
" /vim-surround

" vim-markdown plugin
let g:vim_markdown_folding_disabled=1
let g:vim_markdown_fenced_languages = ['ruby', 'python', 'bash=sh', 'html']
" /vim-markdown

" ??
let g:rct_completion_use_fri=0
command! -bar -nargs=1 OpenURL :!open <args>

" fzf.vim plugin
" Mapping selecting mappings
nmap <leader><tab> <plug>(fzf-maps-n)
xmap <leader><tab> <plug>(fzf-maps-x)
omap <leader><tab> <plug>(fzf-maps-o)
" Insert mode completion
imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-f> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
imap <c-x><c-l> <plug>(fzf-complete-line)

" Ag plugin: Ack, better
if executable('ag')
  let g:ackprg = 'ag --vimgrep --smart-case'
endif

" Neomake plugin
call neomake#configure#automake('nrwi', 500)


" Commands
" ########

" Tidy
command! -range=% Tidy :<line1>,<line2>!tidy -quiet -indent -clean -bare -wrap 0 --show-errors 0 --show-body-only auto

" Visual mode copy to pastebuffer
" kudos to Brad: http://xtargets.com/2010/10/13/cutting-and-pasting-source-code-from-vim-to-skype/
function! CopyWithLineNumbers() range
    redir @*
    sil echomsg "----------------------"
    sil echomsg expand("%")
    sil echomsg "----------------------"
    exec 'sil!' . a:firstline . ',' . a:lastline . '#'
    redir END
endfunction
com! -range CopyWithLineNumbers <line1>,<line2>call CopyWithLineNumbers()

" w!! to save with root permissions
cmap w!! w !sudo tee % > /dev/null

runtime macros/matchit.vim

" Cursorline gets broken by something above, so do it last
set cursorline
highlight CursorLine term=none cterm=none ctermbg=darkgrey guibg=#272727
highlight ColorColumn ctermbg=darkgrey guibg=#272727
" Highlight column 1 & 21 chars past textwidth
let &colorcolumn='+1,+'.join(range(21,80),',+')
